{"version":3,"file":"leaflet-rotate.js","sources":["../src/dom/DomUtil.js","../src/dom/Draggable.js","../src/geometry/Point.js","../src/layer/DivOverlay.js","../src/layer/Popup.js","../src/layer/Tooltip.js","../src/layer/marker/Icon.js","../src/layer/marker/Marker.js","../src/layer/tile/GridLayer.js","../src/layer/vector/Renderer.js","../src/map/Map.js","../src/map/handler/CompassBearing.js","../src/map/handler/ContainerMutation.js","../src/map/handler/TouchGestures.js","../src/map/handler/TouchRotate.js","../src/map/handler/ShiftKeyRotate.js","../src/map/handler/TouchZoom.js","../src/control/Rotate.js"],"sourcesContent":["/**\n * @external L.DomUtil\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/DomUtil.js\n */\n\nconst domUtilProto = L.extend({}, L.DomUtil);\n\nL.extend(L.DomUtil, {\n\n    /**\n     * Resets the 3D CSS transform of `el` so it is\n     * translated by `offset` pixels and optionally\n     * scaled by `scale`. Does not have an effect if\n     * the browser doesn't support 3D CSS transforms.\n     * \n     * @param {HTMLElement} el \n     * @param {L.Point} offset \n     * @param {Number} scale\n     * @param {Number} bearing \n     * @param {L.Point} pivot \n     */\n    setTransform: function(el, offset, scale, bearing, pivot) {\n        var pos = offset || new L.Point(0, 0);\n\n        if (!bearing) {\n            offset = pos._round();\n            return domUtilProto.setTransform.apply(this, arguments);\n        }\n\n        pos = pos.rotateFrom(bearing, pivot);\n\n        el.style[L.DomUtil.TRANSFORM] =\n            'translate3d(' + pos.x + 'px,' + pos.y + 'px' + ',0)' +\n            (scale ? ' scale(' + scale + ')' : '') +\n            ' rotate(' + bearing + 'rad)';\n    },\n\n    /**\n     * Sets the position of `el` to coordinates specified by\n     * `position`, using CSS translate or top/left positioning\n     * depending on the browser (used by Leaflet internally\n     * to position its layers).\n     * \n     * @param {HTMLElement} el \n     * @param {L.Point} point \n     * @param {Number} bearing\n     * @param {L.Point} pivot \n     * @param {Number} scale \n     */\n    setPosition: function(el, point, bearing, pivot, scale) {\n        if (!bearing) {\n            return domUtilProto.setPosition.apply(this, arguments);\n        }\n\n        /*eslint-disable */\n        el._leaflet_pos = point;\n        /*eslint-enable */\n\n        if (L.Browser.any3d) {\n            L.DomUtil.setTransform(el, point, scale, bearing, pivot);\n        } else {\n            el.style.left = point.x + 'px';\n            el.style.top = point.y + 'px';\n        }\n    },\n\n    /**\n     * @constant radians = degrees × π/180°\n     */\n    DEG_TO_RAD: Math.PI / 180,\n\n    /**\n     * @constant degrees = radians × 180°/π\n     */\n    RAD_TO_DEG: 180 / Math.PI,\n\n});\n","/**\n * @external L.Draggable\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/Draggable.js\n */\n\n/**\n * A class for making DOM elements draggable (including touch support).\n * Used internally for map and marker dragging. Only works for elements\n * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).\n */\n\nL.Draggable.include({\n\n    /** @TODO */\n    // updateMapBearing: function(mapBearing) {\n    //     this._mapBearing = mapBearing;\n    // },\n\n});","/**\n * @external L.Point\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/geometry/Point.js\n */\n\nL.extend(L.Point.prototype, {\n\n    /**\n     * Rotate around (0,0) by applying the 2D rotation matrix:\n     * \n     * ⎡ x' ⎤ = ⎡ cos θ  -sin θ ⎤ ⎡ x ⎤\n     * ⎣ y' ⎦   ⎣ sin θ   cos θ ⎦ ⎣ y ⎦\n     * \n     * @param theta must be given in radians.\n     */\n    rotate: function(theta) {\n        return this.rotateFrom(theta, new L.Point(0,0))\n    },\n\n    /**\n     * Rotate around (pivot.x, pivot.y) by:\n     * \n     * 1. subtract (pivot.x, pivot.y)\n     * 2. rotate around (0, 0)\n     * 3. add (pivot.x, pivot.y) back\n     * \n     * same as `this.subtract(pivot).rotate(theta).add(pivot)`\n     * \n     * @param {Number} theta \n     * @param {L.Point} pivot \n     * \n     * @returns {L.Point}\n     */\n    rotateFrom: function(theta, pivot) {\n        if (!theta) { return this; }\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta);\n        var cx = pivot.x,\n            cy = pivot.y;\n        var x = this.x - cx,\n            y = this.y - cy;\n\n        return new L.Point(\n            x * cosTheta - y * sinTheta + cx,\n            x * sinTheta + y * cosTheta + cy\n        );\n    },\n\n});\n","/**\n * @external L.DivOverlay\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/DivOverlay.js\n */\n\nconst divOverlayProto = L.extend({}, L.DivOverlay.prototype);\n\nL.DivOverlay.include({\n\n    /**\n     * Update L.Popup and L.Tooltip anchor positions after\n     * the map is moved by calling `map.setBearing(theta)`\n     * \n     * @listens L.Map~rotate\n     */\n    getEvents: function() {\n        return L.extend(divOverlayProto.getEvents.apply(this, arguments), { rotate: this._updatePosition });\n    },\n\n    /**\n     * 0. update element anchor point (divOverlayProto v1.9.3)\n     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)\n     */\n    _updatePosition: function() {\n        if (!this._map) { return; }\n        divOverlayProto._updatePosition.apply(this, arguments);\n        if (this._map && this._map._rotate && this._zoomAnimated) {\n            var anchor = this._getAnchor();\n            var pos = L.DomUtil.getPosition(this._container).subtract(anchor);\n            L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(pos).add(anchor));\n        }\n\n    },\n\n});\n","/**\n * @external L.Popup\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/Popup.js\n */\n\nconst popupProto = L.extend({}, L.Popup.prototype);\n\nL.Popup.include({\n\n    /**\n     * 0. update element anchor point (popupProto v1.9.3)\n     * 1. rotate around anchor point (subtract anchor -> rotate point -> add anchor)\n     */\n    _animateZoom: function(e) {\n        popupProto._animateZoom.apply(this, arguments);\n        if (this._map && this._map._rotate) {\n            var anchor = this._getAnchor();\n            var pos = L.DomUtil.getPosition(this._container).subtract(anchor);\n            L.DomUtil.setPosition(this._container, this._map.rotatedPointToMapPanePoint(pos).add(anchor));\n        }\n    },\n\n    /**\n     * Fix for L.popup({ keepInView = true })\n     * \n     * @see https://github.com/fnicollet/Leaflet/pull/21\n     */\n    _adjustPan: function() {\n        if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }\n\n        // We can endlessly recurse if keepInView is set and the view resets.\n        // Let's guard against that by exiting early if we're responding to our own autopan.\n        if (this._autopanning) {\n            this._autopanning = false;\n            return;\n        }\n\n        var map = this._map,\n            marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,\n            containerHeight = this._container.offsetHeight + marginBottom,\n            containerWidth = this._containerWidth,\n            layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);\n\n        layerPos._add(L.DomUtil.getPosition(this._container));\n\n        /** @TODO use popupProto._adjustPan */\n        // var containerPos = map.layerPointToContainerPoint(layerPos);\n        var containerPos = layerPos._add(this._map._getMapPanePos()),\n            padding = L.point(this.options.autoPanPadding),\n            paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),\n            paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),\n            size = map.getSize(),\n            dx = 0,\n            dy = 0;\n\n        if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right\n            dx = containerPos.x + containerWidth - size.x + paddingBR.x;\n        }\n        if (containerPos.x - dx - paddingTL.x < 0) { // left\n            dx = containerPos.x - paddingTL.x;\n        }\n        if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom\n            dy = containerPos.y + containerHeight - size.y + paddingBR.y;\n        }\n        if (containerPos.y - dy - paddingTL.y < 0) { // top\n            dy = containerPos.y - paddingTL.y;\n        }\n\n        // @namespace Map\n        // @section Popup events\n        // @event autopanstart: Event\n        // Fired when the map starts autopanning when opening a popup.\n        if (dx || dy) {\n            // Track that we're autopanning, as this function will be re-ran on moveend\n            if (this.options.keepInView) {\n                this._autopanning = true;\n            }\n            map\n                .fire('autopanstart')\n                .panBy([dx, dy]);\n        }\n    },\n\n});\n","/**\n * @external L.Tooltip\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/Tooltip.js\n */\n\nconst tooltipProto = L.extend({}, L.Tooltip.prototype);\n\nL.Tooltip.include({\n\n    _animateZoom: function(e) {\n        if (!this._map._rotate) {\n            return tooltipProto._animateZoom.apply(this, arguments);\n        }\n        var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);\n\n        pos = this._map.rotatedPointToMapPanePoint(pos);\n        this._setPosition(pos);\n    },\n\n    _updatePosition: function() {\n        if (!this._map._rotate) {\n            return tooltipProto._updatePosition.apply(this, arguments);\n        }\n        var pos = this._map.latLngToLayerPoint(this._latlng);\n\n        pos = this._map.rotatedPointToMapPanePoint(pos);\n        this._setPosition(pos);\n    },\n\n});\n","/**\n * @external L.Icon\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Icon.js\n */\n\nconst iconProto = L.extend({}, L.Icon.prototype);\n\nL.Icon.include({\n\n    _setIconStyles: function(img, name) {\n        var options = this.options;\n        var sizeOption = options[name + 'Size'];\n\n        if (typeof sizeOption === 'number') {\n            sizeOption = [sizeOption, sizeOption];\n        }\n\n        var size = L.point(sizeOption),\n            anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||\n                size && size.divideBy(2, true));\n\n        img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');\n\n        if (anchor) {\n            img.style.marginLeft = (-anchor.x) + 'px';\n            img.style.marginTop = (-anchor.y) + 'px';\n            /** @TODO use iconProto._setIconStyles */\n            img.style[L.DomUtil.TRANSFORM + \"Origin\"] = anchor.x + \"px \" + anchor.y + \"px 0px\";\n        }\n\n        if (size) {\n            img.style.width = size.x + 'px';\n            img.style.height = size.y + 'px';\n        }\n    },\n\n});\n","/**\n * @external L.Marker\n * @external L.Handler.MarkerDrag\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Marker.js\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/marker/Marker.Drag.js\n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/dom/Draggable.js\n */\n\nconst markerProto = L.extend({}, L.Marker.prototype);\n\nL.Marker.mergeOptions({\n\n    /**\n     * Rotation of this marker in rad\n     * \n     * @type {Number}\n     */\n    rotation: 0,\n\n    /**\n     * Rotate this marker when map rotates\n     * \n     * @type {Boolean}\n     */\n    rotateWithView: false,\n\n    /**\n     * Scale of the marker icon\n     * \n     * @type {Number}\n     */\n    scale: undefined,\n\n});\n\nvar markerDragProto; // retrived at runtime (see below: L.Marker::_initInteraction())\n\nvar MarkerDrag = {\n\n    // _onDragStart: function() {\n    //     if (!this._marker._map._rotate) {\n    //         return markerDragProto._onDragStart.apply(this, arguments);\n    //     }\n    //     this._draggable.updateMapBearing(this._marker._map._bearing);\n    // },\n\n    _onDrag: function(e) {\n        var marker = this._marker,\n            /** @TODO use markerDragProto._onDrag */\n            rotated_marker = marker.options.rotation || marker.options.rotateWithView,\n            shadow = marker._shadow,\n            iconPos = L.DomUtil.getPosition(marker._icon);\n\n        /** @TODO use markerDragProto._onDrag */\n        // update shadow position\n        if (!rotated_marker && shadow) {\n            L.DomUtil.setPosition(shadow, iconPos);\n        }\n\n        /** @TODO use markerDragProto._onDrag */\n        if (marker._map._rotate) {\n            // Reverse calculation from mapPane coordinates to rotatePane coordinates\n            iconPos = marker._map.mapPanePointToRotatedPoint(iconPos);\n        }\n        var latlng = marker._map.layerPointToLatLng(iconPos);\n\n        marker._latlng = latlng;\n        e.latlng = latlng;\n        e.oldLatLng = this._oldLatLng;\n\n        /** @TODO use markerDragProto._onDrag */\n        if (rotated_marker) marker.setLatLng(latlng); // use `setLatLng` to presisit rotation. low efficiency\n        else marker.fire('move', e); // `setLatLng` will trig 'move' event. we imitate here.\n\n        // @event drag: Event\n        // Fired repeatedly while the user drags the marker.\n        marker\n            .fire('drag', e);\n    },\n\n    _onDragEnd: function(e) {\n        if (this._marker._map._rotate) {\n            this._marker.update();\n        }\n        markerDragProto._onDragEnd.apply(this, arguments);\n    },\n\n};\n\nL.Marker.include({\n\n    /**\n     * Update L.Marker anchor position after the map\n     * is moved by calling `map.setBearing(theta)`\n     * \n     * @listens L.Map~rotate\n     */\n    getEvents: function() {\n        return L.extend(markerProto.getEvents.apply(this, arguments), { rotate: this.update });\n    },\n\n    _initInteraction: function() {\n        var ret = markerProto._initInteraction.apply(this, arguments);\n        if (this.dragging && this.dragging.enabled() && this._map && this._map._rotate) {\n            // L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable\n            markerDragProto = markerDragProto || Object.getPrototypeOf(this.dragging);\n            this.dragging.disable();\n            Object.assign(this.dragging, {\n                // _onDragStart: MarkerDrag._onDragStart.bind(this.dragging),\n                _onDrag: MarkerDrag._onDrag.bind(this.dragging),\n                _onDragEnd: MarkerDrag._onDragEnd.bind(this.dragging),\n            });\n            this.dragging.enable();\n        }\n        return ret;\n    },\n\n    _setPos: function(pos) {\n\n        /** @TODO use markerProto._setPos */\n        if (this._map._rotate) {\n            pos = this._map.rotatedPointToMapPanePoint(pos);\n        }\n\n        /** @TODO use markerProto._setPos */\n        var bearing = this.options.rotation || 0;\n        if (this.options.rotateWithView) {\n            bearing += this._map._bearing;\n        }\n\n        /** @TODO use markerProto._setPos */\n        if (this._icon) {\n            L.DomUtil.setPosition(this._icon, pos, bearing, pos, this.options.scale);\n        }\n\n        /** @TODO use markerProto._setPos */\n        if (this._shadow) {\n            L.DomUtil.setPosition(this._shadow, pos, bearing, pos, this.options.scale);\n        }\n\n        this._zIndex = pos.y + this.options.zIndexOffset;\n\n        this._resetZIndex();\n    },\n\n    // _updateZIndex: function(offset) {\n    //     if (!this._map._rotate) {\n    //         return markerProto._updateZIndex.apply(this, arguments);\n    //     }\n    //     this._icon.style.zIndex = Math.round(this._zIndex + offset);\n    // },\n\n    setRotation: function(rotation) {\n        this.options.rotation = rotation;\n        this.update();\n    },\n\n});\n","/**\n * @external L.GridLayer\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/tile/GridLayer.js\n */\n\nconst gridLayerProto = L.extend({}, L.GridLayer.prototype);\n\nL.GridLayer.include({\n\n    /**\n     * Redraw L.TileLayer bounds after the map is\n     * moved by just calling `map.setBearing(theta)`\n     * \n     * @listens L.Map~rotate\n     */\n    getEvents: function() {\n        var events = gridLayerProto.getEvents.apply(this, arguments);\n        if (this._map._rotate && !this.options.updateWhenIdle) {\n            if (!this._onRotate) {\n                this._onRotate = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);\n            }\n            events.rotate = this._onRotate;\n        }\n        return events;\n    },\n\n    _getTiledPixelBounds: function(center) {\n        if (!this._map._rotate) {\n            return gridLayerProto._getTiledPixelBounds.apply(this, arguments);\n        }\n\n        return this._map._getNewPixelBounds(center, this._tileZoom);\n    },\n\n});\n","/**\n * @external L.Renderer\n * \n * @see https://github.com/Leaflet/Leaflet/tree/v1.9.3/src/layer/vector/Renderer.js\n */\n\nconst rendererProto = L.extend({}, L.Renderer.prototype);\n\nL.Renderer.include({\n\n    /**\n     * Redraw L.Canvas and L.SVG renderer bounds after the\n     * map is moved by just calling `map.setBearing(theta)`\n     * \n     * @listens L.Map~rotate\n     */\n    getEvents: function() {\n        return L.extend(rendererProto.getEvents.apply(this, arguments), { rotate: this._update });\n    },\n\n    /**\n     * Fix for `map.flyTo()` when `false === map.options.zoomAnimation`\n     * \n     * @see https://github.com/Leaflet/Leaflet/pull/8794\n     */\n    onAdd: function() {\n        rendererProto.onAdd.apply(this, arguments);\n        if (L.version <= \"1.9.3\") {\n            // always keep transform-origin as 0 0\n            this._container.classList.add('leaflet-zoom-animated');\n        }\n    },\n\n    /**\n     * @FIXME layer drifts on `map.setZoom()` (eg. zoom during animation)\n     * \n     * the main cause seems to be related to `this._updateTransform(path._center, path._zoom))`\n     * and `this._topLeft = this._map.layerPointToLatLng(this._bounds.min);`\n     * \n     * @example\n     *   map.setZoom(2);\n     *   path._renderer._update();\n     *   path._renderer._updateTransform(path._renderer._center, path._renderer._zoom);\n     * \n     * @see https://github.com/Leaflet/Leaflet/pull/8794\n     * @see https://github.com/Leaflet/Leaflet/pull/8103\n     * @see https://github.com/Leaflet/Leaflet/issues/7466\n     * \n     * @TODO rechek this changes from leaflet@v1.9.3\n     * \n     * @see https://github.com/Leaflet/Leaflet/compare/v1.7.0...v1.9.3\n     */\n    _updateTransform: function(center, zoom) {\n        if (!this._map._rotate) {\n            return rendererProto._updateTransform.apply(this, arguments);\n        }\n        /**\n         * @FIXME see path._renderer._reset();\n         */\n        var scale = this._map.getZoomScale(zoom, this._zoom),\n            offset = this._map._latLngToNewLayerPoint(this._topLeft, zoom, center);\n\n        L.DomUtil.setTransform(this._container, offset, scale);\n        \n    },\n\n    // getEvents() {\n    //     const events = {\n    //         viewreset: this._reset,\n    //         zoom: this._onZoom,\n    //         moveend: this._update,\n    //         zoomend: this._onZoomEnd\n    //     };\n    //     if (this._zoomAnimated) {\n    //         events.zoomanim = this._onAnimZoom;\n    //     }\n    //     return events;\n    // },\n\n    // _onAnimZoom(ev) {\n    //     this._updateTransform(ev.center, ev.zoom);\n    // },\n\n\t// _onZoom() {\n    //     this._updateTransform(this._map.getCenter(), this._map.getZoom());\n\t// },\n\n    // _onZoomEnd() {\n    //     for (const id in this._layers) {\n    //         this._layers[id]._project();\n    //     }\n    // },\n\n    // _reset() {\n    //     this._update();\n    //     this._updateTransform(this._center, this._zoom);\n\n    //     for (const id in this._layers) {\n    //         this._layers[id]._reset();\n    //     }\n    // },\n\n    // _updatePaths() {\n    //     for (const id in this._layers) {\n    //         this._layers[id]._update();\n    //     }\n    // },\n\n    _update: function() {\n        if (!this._map._rotate) {\n            return rendererProto._update.apply(this, arguments);\n        }\n        // Update pixel bounds of renderer container (for positioning/sizing/clipping later)\n        // Subclasses are responsible of firing the 'update' event.\n        this._bounds = this._map._getPaddedPixelBounds(this.options.padding);\n        this._topLeft = this._map.layerPointToLatLng(this._bounds.min);\n        this._center = this._map.getCenter();\n        this._zoom = this._map.getZoom();\n    },\n\n});\n","/**\n * @external L.Map\n * \n * @see https://github.com/Leaflet/Leaflet/blob/v1.9.3/src/map/Map.js\n */\n\nconst mapProto = L.extend({}, L.Map.prototype);\n\nL.Map.mergeOptions({ rotate: false, bearing: 0, });\n\nL.Map.prototype._animateZoomNoDelay = function (center, zoom, startAnim) { \n    if (!this._mapPane) { return; }\n\n    if (startAnim) {\n        this._animatingZoom = true;\n\n        // remember what center/zoom to set after animation\n        this._animateToCenter = center;\n        this._animateToZoom = zoom;\n\n        this._mapPane.classList.add('leaflet-zoom-anim');\n    }\n    this._onZoomTransitionEnd()\n}\n\nL.Map.include({\n\n    /**\n     * @param {(HTMLElement|String)} id html selector\n     * @param {Object} [options={}] leaflet map options\n     */\n    initialize: function(id, options) {\n        if (options.rotate) {\n            this._rotate = true;\n            this._bearing = 0;\n        }\n        mapProto.initialize.apply(this, arguments);\n        if(this.options.rotate){\n          this.setBearing(this.options.bearing);\n        }\n    },\n\n    /**\n     * Given a pixel coordinate relative to the map container,\n     * returns the corresponding pixel coordinate relative to\n     * the [origin pixel](#map-getpixelorigin).\n     * \n     * @param {L.Point} point pixel screen coordinates\n     * @returns {L.Point} transformed pixel point\n     */\n    containerPointToLayerPoint: function(point) {\n        if (!this._rotate) {\n            return mapProto.containerPointToLayerPoint.apply(this, arguments);\n        }\n        return L.point(point)\n            .subtract(this._getMapPanePos())\n            .rotateFrom(-this._bearing, this._getRotatePanePos())\n            .subtract(this._getRotatePanePos());\n    },\n\n    /**\n     * Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),\n     * returns the corresponding pixel coordinate relative to the map container.\n     * \n     * @param {L.Point} point pixel screen coordinates\n     * @returns {L.Point} transformed pixel point\n     */\n    layerPointToContainerPoint: function(point) {\n        if (!this._rotate) {\n            return mapProto.layerPointToContainerPoint.apply(this, arguments);\n        }\n        return L.point(point)\n            .add(this._getRotatePanePos())\n            .rotateFrom(this._bearing, this._getRotatePanePos())\n            .add(this._getMapPanePos());\n    },\n\n    /**\n     * Converts a coordinate from the rotated pane reference system\n     * to the reference system of the not rotated map pane.\n     * \n     * (rotatePane) --> (mapPane)\n     * (rotatePane) --> (norotatePane)\n     * \n     * @param {L.Point} point pixel screen coordinates\n     * @returns {L.Point}\n     * \n     * @since leaflet-rotate (v0.1)\n     */\n    rotatedPointToMapPanePoint: function(point) {\n        return L.point(point)\n            .rotate(this._bearing)\n            ._add(this._getRotatePanePos());\n    },\n\n    /**\n     * Converts a coordinate from the not rotated map pane reference system\n     * to the reference system of the rotated pane.\n     * \n     * (mapPane) --> (rotatePane)\n     * (norotatePane) --> (rotatePane)\n     * \n     * @param {L.Point} point pixel screen coordinates\n     * \n     * @since leaflet-rotate (v0.1)\n     */\n    mapPanePointToRotatedPoint: function(point) {\n        return L.point(point)\n            ._subtract(this._getRotatePanePos())\n            .rotate(-this._bearing);\n    },\n\n    // latLngToLayerPoint: function (latlng) {\n    //     var projectedPoint = this.project(L.latLng(latlng))._round();\n    //     return projectedPoint._subtract(this.getPixelOrigin());\n    // },\n\n    // latLngToContainerPoint: function (latlng) {\n\t// \treturn this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));\n\t// },\n\n    /**\n     * Given latlng bounds, returns the bounds in projected pixel\n     * relative to the map container.\n     * \n     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/map/Map.js#L1114-L1135\n     * \n     * @param {L.LatLngBounds} bounds \n     * @returns {L.Bounds}\n     * \n     * @since leaflet-rotate (v0.2)\n     */\n    mapBoundsToContainerBounds: function (bounds) {\n        if (!this._rotate && mapProto.mapBoundsToContainerBounds) {\n            return mapProto.mapBoundsToContainerBounds.apply(this, arguments);\n        }\n\n        // const nw = this.latLngToContainerPoint(bounds.getNorthWest()),\n        //       ne = this.latLngToContainerPoint(bounds.getNorthEast()),\n        //       sw = this.latLngToContainerPoint(bounds.getSouthWest()),\n        //       se = this.latLngToContainerPoint(bounds.getSouthEast());\n\n        // same as `this.latLngToContainerPoint(latlng)` but with floating point precision\n        const origin = this.getPixelOrigin();\n        const nw = this.layerPointToContainerPoint(this.project(bounds.getNorthWest())._subtract(origin)),\n              ne = this.layerPointToContainerPoint(this.project(bounds.getNorthEast())._subtract(origin)),\n              sw = this.layerPointToContainerPoint(this.project(bounds.getSouthWest())._subtract(origin)),\n              se = this.layerPointToContainerPoint(this.project(bounds.getSouthEast())._subtract(origin));\n\n        return L.bounds([\n            L.point(Math.min(nw.x, ne.x, se.x, sw.x), Math.min(nw.y, ne.y, se.y, sw.y)), // [ minX, minY ]\n            L.point(Math.max(nw.x, ne.x, se.x, sw.x), Math.max(nw.y, ne.y, se.y, sw.y))  // [ maxX, maxY ]\n        ]);\n    },\n\n    /**\n     * Returns geographical bounds visible in the current map view\n     * \n     * @TODO find out  if map bounds calculated by `L.Map::getBounds()`\n     *       function should match the `rotatePane` or `norotatePane` bounds\n     * \n     * @see https://github.com/fnicollet/Leaflet/issues/7\n     * \n     * @returns {L.LatLngBounds}\n     */\n    getBounds: function() {\n        if (!this._rotate) {\n            return mapProto.getBounds.apply(this, arguments);\n        }\n\n        // SEE: https://github.com/fnicollet/Leaflet/pull/22\n        //\n        // var bounds = this.getPixelBounds(),\n        // sw = this.unproject(bounds.getBottomLeft()),\n        // ne = this.unproject(bounds.getTopRight());\n        // return new LatLngBounds(sw, ne);\n        //\n\n        // LatLngBounds' constructor automatically\n        // extends the bounds to fit the passed points\n        var size = this.getSize();\n        return new L.LatLngBounds([\n            this.containerPointToLatLng([0, 0]),           // topleft\n            this.containerPointToLatLng([size.x, 0]),      // topright \n            this.containerPointToLatLng([size.x, size.y]), // bottomright\n            this.containerPointToLatLng([0, size.y]),      // bottomleft\n        ]);\n    },\n\n    /**\n     * Returns the bounds of the current map view in projected pixel\n     * coordinates (sometimes useful in layer and overlay implementations).\n     * \n     * @TODO find out if map bounds calculated by `L.Map::getPixelBounds()`\n     *       function should match the `rotatePane` or `norotatePane` bounds\n     *\n     * @see https://github.com/fnicollet/Leaflet/issues/7\n     * \n     * @returns {L.Bounds}\n     */\n    // getPixelBounds(center, zoom) {\n    //     // const topLeftPoint = map.containerPointToLayerPoint(this._getTopLeftPoint());\n    //     const topLeftPoint = this._getTopLeftPoint(center, zoom);\n    //       return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));\n    // },\n\n    /**\n     * Change map rotation\n     * \n     * @param {number} theta map degrees\n     * @param {L.Point} rotation center offset in screen pixels to apply\n     * \n     * @since leaflet-rotate (v0.1)\n     */\n    setBearing: function(theta, offset = L.point(0, 0)) {\n        if (!L.Browser.any3d || !this._rotate) { return; }\n\n        var bearing = L.Util.wrapNum(theta, [0, 360]) * L.DomUtil.DEG_TO_RAD,\n            center = this._getPixelCenter().add(L.point(offset)),\n            oldPos = this._getRotatePanePos().rotateFrom(-this._bearing, center),\n            newPos = oldPos.rotateFrom(bearing, center);\n\n        // CSS transform\n        L.DomUtil.setPosition(this._rotatePane, oldPos, bearing, center);\n\n        this._pivot = center;\n        this._bearing = bearing;\n        this._rotatePanePos = newPos;\n\n        this.fire('rotate');\n    },\n\n    /**\n     * Get current map rotation\n     * \n     * @returns {number} theta map degrees\n     * \n     * @since leaflet-rotate (v0.1)\n     */\n    getBearing: function() {\n        return this._bearing * L.DomUtil.RAD_TO_DEG;\n    },\n\n    /**\n     * Creates a new [map pane](#map-pane) with the given name if it doesn't\n     * exist already, then returns it. The pane is created as a child of\n     * `container`, or as a child of the main map pane if not set.\n     * \n     * @param {String} name leaflet pane\n     * @param {HTMLElement} [container] parent element\n     * @returns {HTMLElement} pane container\n     */\n    // createPane: function(name, container) {\n    //     if (!this._rotate || name == 'mapPane') {\n    //         return mapProto.createPane.apply(this, arguments);\n    //     }\n    //     // init \"rotatePane\"\n    //     if (!this._rotatePane) {\n    //         // this._pivot = this.getSize().divideBy(2);\n    //         this._rotatePane = mapProto.createPane.call(this, 'rotatePane', this._mapPane);\n    //         L.DomUtil.setPosition(this._rotatePane, new L.Point(0, 0), this._bearing, this._pivot);\n    //     }\n    //     return mapProto.createPane.call(this, name, container || this._rotatePane);\n    // },\n\n    /**\n     * Panes are DOM elements used to control the ordering of layers on\n     * the map. You can access panes with [`map.getPane`](#map-getpane)\n     * or [`map.getPanes`](#map-getpanes) methods. New panes can be created\n     * with the [`map.createPane`](#map-createpane) method.\n     * \n     * Every map has the following default panes that differ only in zIndex:\n     * \n     * - mapPane     [HTMLElement = 'auto'] - Pane that contains all other map panes\n     * - tilePane    [HTMLElement = 2]      - Pane for tile layers\n     * - overlayPane [HTMLElement = 4]      - Pane for overlays like polylines and polygons\n     * - shadowPane  [HTMLElement = 5]      - Pane for overlay shadows (e.g. marker shadows)\n     * - markerPane  [HTMLElement = 6]      - Pane for marker icons\n     * - tooltipPane [HTMLElement = 650]    - Pane for tooltips.\n     * - popupPane   [HTMLElement = 700]    - Pane for popups.\n     */\n    _initPanes: function() {\n        var panes = this._panes = {};\n        this._paneRenderers = {};\n\n        this._mapPane = this.createPane('mapPane', this._container);\n        L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));\n\n        if (this._rotate) {\n            this._rotatePane = this.createPane('rotatePane', this._mapPane);\n            this._norotatePane = this.createPane('norotatePane', this._mapPane);\n            // rotatePane\n            this.createPane('tilePane', this._rotatePane);\n            this.createPane('overlayPane', this._rotatePane);\n            // norotatePane\n            this.createPane('shadowPane', this._norotatePane);\n            this.createPane('markerPane', this._norotatePane);\n            this.createPane('tooltipPane', this._norotatePane);\n            this.createPane('popupPane', this._norotatePane);\n        } else {\n            this.createPane('tilePane');\n            this.createPane('overlayPane');\n            this.createPane('shadowPane');\n            this.createPane('markerPane');\n            this.createPane('tooltipPane');\n            this.createPane('popupPane');\n        }\n\n        if (!this.options.markerZoomAnimation) {\n            L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');\n            L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');\n        }\n    },\n\n    /**\n     * Pans the map the minimum amount to make the `latlng` visible. Use\n     * padding options to fit the display to more restricted bounds.\n     * If `latlng` is already within the (optionally padded) display bounds,\n     * the map will not be panned.\n     * \n     * @see https://github.com/Raruto/leaflet-rotate/issues/18\n     * \n     * @param {L.LatLng} latlng coordinates\n     * @param {Object} [options={}] padding options\n     * \n     * @returns {L.Map} current map instance\n     */\n    panInside(latlng, options) {\n        if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1) {\n            return mapProto.panInside.apply(this, arguments);\n        }\n\n        options = options || {};\n\n        const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\n            paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),\n            /** @TODO use mapProto.panInside */\n            // pixelPoint = this.project(latlng),\n            // pixelBounds = this.getPixelBounds(),\n            // pixelCenter = this.project(this.getCenter()),\n            rect = this._container.getBoundingClientRect(),\n            pixelPoint = this.latLngToContainerPoint(latlng),\n            pixelBounds = L.bounds([ L.point(rect), L.point(rect).add(this.getSize()) ]),\n            pixelCenter = pixelBounds.getCenter(),\n            //\n            paddedBounds = L.bounds([pixelBounds.min.add(paddingTL), pixelBounds.max.subtract(paddingBR)]),\n            paddedSize = paddedBounds.getSize();\n        \n        if (!paddedBounds.contains(pixelPoint)) {\n            this._enforcingBounds = true;\n            const centerOffset = pixelPoint.subtract(paddedBounds.getCenter());\n            const offset = paddedBounds.extend(pixelPoint).getSize().subtract(paddedSize);\n            pixelCenter.x += centerOffset.x < 0 ? -offset.x : offset.x;\n            pixelCenter.y += centerOffset.y < 0 ? -offset.y : offset.y;\n            /** @TODO use mapProto.panInside */\n            // this.panTo(this.unproject(pixelCenter), options);\n            this.panTo(this.containerPointToLatLng(pixelCenter), options);\n            //\n            this._enforcingBounds = false;\n        }\n        return this;\n    },\n\n    /**\n     * Pans the map to the closest view that would lie inside the given bounds\n     * (if it's not already), controlling the animation using the options specific,\n     * if any.\n     * \n     * @TODO check if map bounds calculated by `L.Map::panInsideBounds()`\n     *       function should match the `rotatePane` or `norotatePane` bounds\n     *\n     * @see https://github.com/fnicollet/Leaflet/issues/7\n     * \n     * @param {L.LatLngBounds} bounds coordinates\n     * @param {Object} [options] pan options\n     * @returns {L.Map} current map instance\n     */\n    // panInsideBounds: function (bounds, options) {\n    //     this._enforcingBounds = true;\n    //     var center = this.getCenter(),\n    //         newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));\n    //\n    //     if (!center.equals(newCenter)) {\n    //         this.panTo(newCenter, options);\n    //     }\n    //\n    //     this._enforcingBounds = false;\n    //     return this;\n    // },\n\n    // adjust center for view to get inside bounds\n    // _limitCenter(center, zoom, bounds) {\n    //\n    //     if (!bounds) { return center; }\n    //\n    //     const centerPoint = this.project(center, zoom),\n    //         viewHalf = this.getSize().divideBy(2),\n    //         viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),\n    //         offset = this._getBoundsOffset(viewBounds, bounds, zoom);\n    //\n    //     // If offset is less than a pixel, ignore.\n    //     // This prevents unstable projections from getting into\n    //     // an infinite loop of tiny offsets.\n    //     if (Math.abs(offset.x) <= 1 && Math.abs(offset.y) <= 1) {\n    //             return center;\n    //     }\n    //\n    //     return this.unproject(centerPoint.add(offset), zoom);\n    // },\n\n    // @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this\n    // Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),\n    // but takes a bounds parameter like [`fitBounds`](#map-fitbounds).\n    // flyToBounds(bounds, options) {\n    //     const target = this._getBoundsCenterZoom(bounds, options);\n    //     return this.flyTo(target.center, target.zoom, options);\n    // },\n\n    // _getBoundsCenterZoom(bounds, options) {\n    //\n    //     options = options || {};\n    //     bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);\n    //\n    //     const paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),\n    //           paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]);\n    //\n    //     let zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));\n    //\n    //     zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;\n    //\n    //     if (zoom === Infinity) {\n    //         return { center: bounds.getCenter(), zoom };\n    //     }\n    //\n    //     return { center, zoom };\n    //\n    // },\n\n    /**\n     * Returns the maximum zoom level on which the given bounds fit to the map\n     * view in its entirety. If `inside` (optional) is set to `true`, the method\n     * instead returns the minimum zoom level on which the map view fits into\n     * the given bounds in its entirety.\n     * \n     * @param {L.LatLngBounds} bounds\n     * @param {Boolean} [inside=false]\n     * @param {L.Point} [padding=[0,0]]\n     * \n     * @returns {Number} zoom level\n     */\n    getBoundsZoom(bounds, inside, padding) {\n        if (!this._rotate || Math.abs(this._bearing).toFixed(1) < 0.1) {\n            return mapProto.getBoundsZoom.apply(this, arguments);\n        }\n\n        bounds = L.latLngBounds(bounds);\n        padding = L.point(padding || [0, 0]);\n\n        let zoom = this.getZoom() || 0;\n        const min = this.getMinZoom(),\n                max = this.getMaxZoom(),\n                /** @TODO use mapProto.getBoundsZoom */\n                // nw = bounds.getNorthWest(),\n                // se = bounds.getSouthEast(),\n                // size = this.getSize().subtract(padding),\n                // boundsSize = L.bounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),\n                size = this.getSize().subtract(padding),\n                boundsSize = this.mapBoundsToContainerBounds(bounds).getSize(),\n                snap = this.options.zoomSnap,\n                scalex = size.x / boundsSize.x,\n                scaley = size.y / boundsSize.y,\n                scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);\n\n        zoom = this.getScaleZoom(scale, zoom);\n\n        if (snap) {\n            zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level\n            zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;\n        }\n\n        return Math.max(min, Math.min(max, zoom));\n    },\n\n    /**\n     * Layer point of the current center\n     * \n     * @returns {L.Point} layer center\n     */\n    // _getCenterLayerPoint: function () {\n    //    return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    // },\n\n    /**\n     * Offset of the specified place to the current center in pixels\n     * \n     * @param {L.LatLng} latlng map coordinates\n     */\n    _getCenterOffset: function(latlng) {\n        var centerOffset = mapProto._getCenterOffset.apply(this, arguments);\n        if (this._rotate) {\n            centerOffset = centerOffset.rotate(this._bearing);\n        }\n        return centerOffset;\n    },\n\n    /**\n     * @since leaflet-rotate (v0.1)\n     */\n    _getRotatePanePos: function() {\n        return this._rotatePanePos || new L.Point(0, 0);\n        // return L.DomUtil.getPosition(this._rotatePane) || new L.Point(0, 0);\n    },\n\n    // _latLngToNewLayerPoint(latlng, zoom, center) {\n    //    const topLeft = this._getNewPixelOrigin(center, zoom);\n    //    return this.project(latlng, zoom)._subtract(topLeft);\n    //},\n\n    _getNewPixelOrigin: function(center, zoom) {\n        if (!this._rotate) {\n            return mapProto._getNewPixelOrigin.apply(this, arguments);\n        }\n        var viewHalf = this.getSize()._divideBy(2);\n        return this.project(center, zoom)\n            .rotate(this._bearing)\n            ._subtract(viewHalf)\n            ._add(this._getMapPanePos())\n            ._add(this._getRotatePanePos())\n            .rotate(-this._bearing)\n            ._round();\n    },\n\n    /**\n     * @since leaflet-rotate (v0.2)\n     * \n     * @see src\\layer\\tile\\GridLayer::_getTiledPixelBounds()\n     */\n    _getNewPixelBounds: function(center, zoom) {\n        center = center || this.getCenter();\n        zoom = zoom || this.getZoom();\n        if (!this._rotate && mapProto._getNewPixelBounds) {\n            return mapProto._getNewPixelBounds.apply(this, arguments);\n        }\n        var mapZoom = this._animatingZoom ? Math.max(this._animateToZoom, this.getZoom()) : this.getZoom(),\n            scale = this.getZoomScale(mapZoom, zoom),\n            pixelCenter = this.project(center, zoom).floor(),\n            size = this.getSize(),\n            halfSize = new L.Bounds([\n                this.containerPointToLayerPoint([0, 0]).floor(),\n                this.containerPointToLayerPoint([size.x, 0]).floor(),\n                this.containerPointToLayerPoint([0, size.y]).floor(),\n                this.containerPointToLayerPoint([size.x, size.y]).floor()\n            ]).getSize().divideBy(scale * 2);\n\n        return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));\n    },\n\n    /**\n     * @since leaflet-rotate (v0.2)\n     * \n     * @return {L.Point} map pivot point (center)\n     */\n    _getPixelCenter: function() {\n        if (!this._rotate && mapProto._getPixelCenter) {\n            return mapProto._getPixelCenter.apply(this, arguments);\n        }\n        return this.getSize()._divideBy(2)._subtract(this._getMapPanePos());\n    },\n\n    /**\n     * @since leaflet-rotate (v0.2)\n     * \n     * @see src\\layer\\vector\\Renderer::_update()\n     */\n    _getPaddedPixelBounds: function(padding) {\n        if (!this._rotate && mapProto._getPaddedPixelBounds) {\n            return mapProto._getPaddedPixelBounds.apply(this, arguments);\n        }\n        var p = padding,\n            size = this.getSize(),\n            padMin = size.multiplyBy(-p),\n            padMax = size.multiplyBy(1 + p);\n            //min = this.containerPointToLayerPoint(size.multiplyBy(-p)).round();\n\n        return new L.Bounds([\n            this.containerPointToLayerPoint([padMin.x, padMin.y]).floor(),\n            this.containerPointToLayerPoint([padMin.x, padMax.y]).floor(),\n            this.containerPointToLayerPoint([padMax.x, padMin.y]).floor(),\n            this.containerPointToLayerPoint([padMax.x, padMax.y]).floor()\n        ]);\n    },\n\n    _handleGeolocationResponse: function(pos) {\n        if (!this._container._leaflet_id) { return; }\n\n        var lat = pos.coords.latitude,\n            lng = pos.coords.longitude,\n            /** @TODO use mapProto._handleGeolocationResponse */\n            hdg = pos.coords.heading,\n            latlng = new L.LatLng(lat, lng),\n            bounds = latlng.toBounds(pos.coords.accuracy),\n            options = this._locateOptions;\n\n        if (options.setView) {\n            var zoom = this.getBoundsZoom(bounds);\n            this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);\n        }\n\n        var data = {\n            latlng: latlng,\n            bounds: bounds,\n            timestamp: pos.timestamp,\n            /** @TODO use mapProto._handleGeolocationResponse */\n            heading: hdg\n        };\n\n        for (var i in pos.coords) {\n            if (typeof pos.coords[i] === 'number') {\n                data[i] = pos.coords[i];\n            }\n        }\n\n        // @event locationfound: LocationEvent\n        // Fired when geolocation (using the [`locate`](#map-locate) method)\n        // went successfully.\n        this.fire('locationfound', data);\n    },\n\n    /**\n     * @see https://github.com/ronikar/Leaflet/blob/5c480ef959b947c3beed7065425a5a36c486262b/src/geo/LatLngBounds.js#L253-L264\n     * \n     * @param {L.Bounds} points \n     * @returns {L.Bounds}\n     */\n    // toCircumscribedBounds(points) {\n    //     var minX = points.reduce(function (pv, v) { return Math.min(pv, v.x); }, points[0].x),\n    //         maxX = points.reduce(function (pv, v) { return Math.max(pv, v.x); }, points[0].x),\n    //         minY = points.reduce(function (pv, v) { return Math.min(pv, v.y); }, points[0].y),\n    //         maxY = points.reduce(function (pv, v) { return Math.max(pv, v.y); }, points[0].y);\n    //\n    //     return L.bounds(L.point(minX, minY), L.point(maxX, maxY));\n    // },\n\n});\n","/**\n * Rotates the map according to a smartphone's compass.\n * \n * @typedef L.Map.CompassBearing\n */\n\nL.Map.CompassBearing = L.Handler.extend({\n\n    initialize: function(map) {\n        this._map = map;\n        /** @see https://caniuse.com/?search=DeviceOrientation */\n        if ('ondeviceorientationabsolute' in window) {\n            this.__deviceOrientationEvent = 'deviceorientationabsolute';\n        } else if('ondeviceorientation' in window) {\n            this.__deviceOrientationEvent = 'deviceorientation';\n        }\n        this._throttled = L.Util.throttle(this._onDeviceOrientation, 100, this);\n    },\n\n    addHooks: function() {\n        if (this._map._rotate && this.__deviceOrientationEvent) {\n            L.DomEvent.on(window, this.__deviceOrientationEvent, this._throttled, this);\n        } else {\n            // L.Map.CompassBearing handler will be automatically\n            // disabled if device orientation is not supported.\n            this.disable();\n        }\n    },\n\n    removeHooks: function() {\n        if (this._map._rotate && this.__deviceOrientationEvent) {\n            L.DomEvent.off(window, this.__deviceOrientationEvent, this._throttled, this);\n        }\n    },\n\n    /**\n     * `DeviceOrientationEvent.absolute` - Indicates whether the device is providing absolute\n     *                                     orientation values (relatives to Magnetic North) or\n     *                                     using some arbitrary frame determined by the device.\n     * \n     * `DeviceOrientationEvent.alpha`    - Returns the rotation of the device around the Z axis;\n     *                                     that is, the number of degrees by which the device is\n     *                                     being twisted around the center of the screen.\n     * \n     * `window.orientation`              - Returns the screen orientation in degrees (in 90-degree increments)\n     *                                     of the viewport relative to the device's natural orientation.\n     *                                     Its only possible values are -90, 0, 90, and 180. Positive\n     *                                     values are counterclockwise; negative values are clockwise.\n     * \n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/absolute\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/DeviceOrientationEvent/alpha\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/orientation\n     */\n    _onDeviceOrientation: function(e) {\n        var angle = e.webkitCompassHeading || e.alpha;\n        var deviceOrientation = 0;\n\n        // Safari iOS\n        if (!e.absolute && e.webkitCompassHeading) {\n            angle = 360 - angle;\n        }\n\n        // Older browsers\n        if (!e.absolute && 'undefined' !== typeof window.orientation) {\n            deviceOrientation = window.orientation;\n        }\n\n        this._map.setBearing(angle - deviceOrientation);\n    },\n\n});\n\n/**\n * Add Compass bearing handler to L.Map (disabled unless `window.DeviceOrientationEvent` is set).\n * \n * @property {L.Map.CompassBearing} compassBearing\n */\nL.Map.addInitHook('addHandler', 'compassBearing', L.Map.CompassBearing);\n","/**\n * Triggers `invalidateResize` when the map's DOM container mutates.\n * \n * @typedef L.Map.ContainerMutation\n */\n\n/**\n * @TODO check again this file after leaflet v1.9.3 (eg. L.Browser.mutation).\n * Mutation Observer support will likely be added by default in next releases.\n */\n\nL.Map.mergeOptions({\n\n    /**\n     * Whether the map uses mutation observers to\n     * detect changes in its container and trigger\n     * `invalidateSize`. Disabled by default due to\n     * support not being available in all web browsers.\n     *\n     * @type {Boolean}\n     * \n     * @see https://developer.mozilla.org/docs/Web/API/MutationObserver\n     */\n    trackContainerMutation: false\n\n});\n\nL.Map.ContainerMutation = L.Handler.extend({\n\n    addHooks: function() {\n        // if (!L.Browser.mutation) { return; }\n        if (!this._observer) {\n            this._observer = new MutationObserver(L.Util.bind(this._map.invalidateSize, this._map));\n        }\n        this._observer.observe(this._map.getContainer(), {\n            childList: false,\n            attributes: true,\n            characterData: false,\n            subtree: false,\n            attributeFilter: ['style']\n        });\n    },\n\n    removeHooks: function() {\n        // if (!L.Browser.mutation) { return; }\n        this._observer.disconnect();\n    },\n\n});\n\n/**\n * Add Container mutation handler to L.Map (disabled unless `trackContainerMutation` is set).\n * \n * @property {L.Map.ContainerMutation} trackContainerMutation\n */\nL.Map.addInitHook('addHandler', 'trackContainerMutation', L.Map.ContainerMutation);\n","/**\n * TouchGestures is both TouchZoom plus TouchRotate\n * \n * @see https://github.com/fnicollet/Leaflet/commit/a77af51a6b10f308d1b9a16552091d1d0aee8834\n * @see https://github.com/Leaflet/Leaflet/blob/v1.9.3/src/map/handler/Map.TouchZoom.js\n * \n * @typedef L.Map.TouchGestures\n */\n\nL.Map.mergeOptions({\n\n    /**\n     * Set it to false if you don't want the map to\n     * zoom beyond min/max zoom and then bounce back\n     * when pinch-zooming.\n     * \n     * @type {Boolean}\n     */\n    bounceAtZoomLimits: true,\n    /**\n     * Set a minimum bearing value (rotate threshold) to\n     * prevent map from rotating when user just wants to\n     * zoom.  \n     * \n     * @type { number | undefined }\n     */\n    touchRotateIntertia: 0\n});\n\nL.Map.TouchGestures = L.Handler.extend({\n\n    initialize: function(map) {\n        this._map = map;\n        this.rotate = !!this._map.options.touchRotate;\n        this.zoom = !!this._map.options.touchZoom;\n    },\n\n    addHooks: function() {\n        L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n\n    removeHooks: function() {\n        L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);\n    },\n\n    _onTouchStart: function(e) {\n        var map = this._map;\n\n        if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming || this._rotating) { return; }\n\n        var p1 = map.mouseEventToContainerPoint(e.touches[0]),\n            p2 = map.mouseEventToContainerPoint(e.touches[1]),\n            vector = p1.subtract(p2);\n\n        this._centerPoint = map.getSize()._divideBy(2);\n        this._startLatLng = map.containerPointToLatLng(this._centerPoint);\n        this._center = this._startLatLng;\n\n        if (this.zoom) {\n            if (map.options.touchZoom !== 'center') {\n                this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));\n            }\n            this._startDist = p1.distanceTo(p2);\n            this._startZoom = map.getZoom();\n            this._zooming = true;\n        } else {\n            this._zooming = false;\n        }\n\n        if (this.rotate) {\n            this._startTheta = Math.atan(vector.x / vector.y);\n            this._startBearing = map.getBearing();\n            if (vector.y < 0) { this._startBearing += 180; }\n            this._rotating = true;\n        } else {\n            this._rotating = false;\n        }\n\n        this._moved = false;\n\n        map._stop();\n\n        L.DomEvent\n            .on(document, 'touchmove', this._onTouchMove, this)\n            .on(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n        L.DomEvent.preventDefault(e);\n    },\n\n    _onTouchMove: function(e) {\n        if (!e.touches || e.touches.length !== 2 || !(this._zooming || this._rotating)) { return; }\n\n        var map = this._map,\n            p1 = map.mouseEventToContainerPoint(e.touches[0]),\n            p2 = map.mouseEventToContainerPoint(e.touches[1]),\n            vector = p1.subtract(p2),\n            scale = p1.distanceTo(p2) / this._startDist,\n            delta;\n        var hasRotated, hasZoomed\n\n        if (this._rotating) {\n            var theta = Math.atan(vector.x / vector.y);\n            var bearingDelta = (theta - this._startTheta) * L.DomUtil.RAD_TO_DEG;\n            if (vector.y < 0) { bearingDelta += 180; }\n            if (Math.abs(bearingDelta) > this._map.options.touchRotateInertia) {\n                /**\n                 * @TODO the pivot should be the last touch point,\n                 * but zoomAnimation manages to overwrite the rotate\n                 * pane position. Maybe related to #3529.\n                 * \n                 * @see https://github.com/Leaflet/Leaflet/pull/3529\n                 * @see https://github.com/fnicollet/Leaflet/commit/a77af51a6b10f308d1b9a16552091d1d0aee8834\n                 */\n                map.setBearing(this._startBearing - bearingDelta);\n                hasRotated = true\n            }\n        }\n\n        if (this._zooming) {\n            this._zoom = map.getScaleZoom(scale, this._startZoom);\n            if (!map.options.bounceAtZoomLimits && (\n                    (this._zoom < map.getMinZoom() && scale < 1) ||\n                    (this._zoom > map.getMaxZoom() && scale > 1))) {\n                this._zoom = map._limitZoom(this._zoom);\n            }\n            if (map.options.touchZoom === 'center') {\n                this._center = this._startLatLng;\n                if (scale === 1) { return; }\n            } else {\n                // Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng\n                delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);\n                if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }\n\n                var alpha = -map.getBearing() * L.DomUtil.DEG_TO_RAD;\n\n                this._center = map.unproject(map.project(this._pinchStartLatLng).subtract(delta.rotate(alpha)));\n            }\n            hasZoomed = true\n        }\n\n        if (!this._moved) {\n            map._moveStart(true, false);\n            this._moved = true;\n        }\n        L.Util.cancelAnimFrame(this._animRequest);\n        if (this._animZoomRequest) L.Util.cancelAnimFrame(this._animZoomRequest);\n        var moveFn = map._move.bind(map, this._center, this._zoom, { pinch: true, round: false });\n        this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);\n        if (hasZoomed) {\n            var zoomFn = map._animateZoomNoDelay.bind(map, this._center, this._map._limitZoom(this._zoom), true);\n            this._animZoomRequest = L.Util.requestAnimFrame(zoomFn, this, true);\n        } else {\n            this._animZoomRequest = null\n        }\n        \n        L.DomEvent.preventDefault(e);\n    },\n\n    _onTouchEnd: function() {\n        if (!this._moved || !(this._zooming || this._rotating)) {\n            this._zooming = false;\n            return;\n        }\n\n        this._zooming = false;\n        this._rotating = false;\n        L.Util.cancelAnimFrame(this._animRequest);\n        L.Util.cancelAnimFrame(this._animZoomRequest);\n\n        L.DomEvent\n            .off(document, 'touchmove', this._onTouchMove, this)\n            .off(document, 'touchend touchcancel', this._onTouchEnd, this);\n\n        if (this.zoom) {\n            // Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.\n            if (this._map.options.zoomAnimation) {\n                this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);\n            } else {\n                this._map._animateZoomNoDelay(this._center, this._map._limitZoom(this._zoom), true);\n            }\n        }\n    },\n\n});\n\n/**\n * Add Touch Gestures handler (enabled unless `touchGestures` is unset).\n * \n * @property {L.Map.TouchGestures} touchGestures\n */\nL.Map.addInitHook('addHandler', 'touchGestures', L.Map.TouchGestures);\n","/**\n * Rotates the map on two-finger (touch devices).\n * \n * @typedef L.Map.TouchRotate\n */\n\nL.Map.mergeOptions({\n\n    /**\n     * Whether the map can be rotated with a two-finger rotation gesture\n     * \n     * @type {Boolean}\n     */\n    touchRotate: false,\n\n});\n\nL.Map.TouchRotate = L.Handler.extend({\n\n    addHooks: function() {\n        this._map.touchGestures.enable();\n        this._map.touchGestures.rotate = true;\n    },\n\n    removeHooks: function() {\n        this._map.touchGestures.rotate = false;\n    },\n\n});\n\n/**\n * Add Touch Rotate handler (disabled unless `touchGestures` is set).\n * \n * @property {L.Map.TouchGestures} touchGestures\n */\nL.Map.addInitHook('addHandler', 'touchRotate', L.Map.TouchRotate);\n","\n/**\n * Rotates the map on shift key + mousewheel scrolling (desktop).\n * \n * @typedef L.Map.ShiftKeyRotate\n */\n\nL.Map.mergeOptions({\n\n    /**\n     * Whether the map can be rotated with shift + wheel scroll\n     * @type {Boolean}\n     */\n    shiftKeyRotate: true,\n\n});\n\nL.Map.ShiftKeyRotate = L.Handler.extend({\n\n    addHooks: function() {\n        L.DomEvent.on(this._map._container, \"wheel\", this._handleShiftScroll, this);\n        // this._map.shiftKeyRotate.enable();\n        this._map.shiftKeyRotate.rotate = true;\n    },\n\n    removeHooks: function() {\n        L.DomEvent.off(this._map._container, \"wheel\", this._handleShiftScroll, this);\n        this._map.shiftKeyRotate.rotate = false;\n    },\n\n    _handleShiftScroll: function(e) {\n        if (e.shiftKey) {\n            e.preventDefault();\n            this._map.scrollWheelZoom.disable();\n            this._map.setBearing((this._map._bearing * L.DomUtil.RAD_TO_DEG) + Math.sign(e.deltaY) * 5);\n        } else {\n            this._map.scrollWheelZoom.enable();\n        }\n    },\n\n});\n\n/**\n * Add ShiftKey handler to L.Map (enabled unless `shiftKeyRotate` is unset).\n * \n * @property {L.Map.ShiftKeyRotate} shiftKeyRotate\n */\nL.Map.addInitHook('addHandler', 'shiftKeyRotate', L.Map.ShiftKeyRotate);\n\n// decrease `scrollWheelZoom` handler priority over `shiftKeyRotate` handler\nL.Map.addInitHook(function() {\n    if (this.scrollWheelZoom.enabled() && this.shiftKeyRotate.enabled()) {\n        this.scrollWheelZoom.disable();\n        this.scrollWheelZoom.enable();\n    }\n});\n","/**\n * Adds pinch zoom rotation on mobile browsers\n * \n * @see https://github.com/Leaflet/Leaflet/blob/v1.9.3/src/map/handler/Map.TouchZoom.js\n * \n * @external L.Map.TouchZoom\n */\n\nL.Map.mergeOptions({\n\n    /**\n     * Whether the map can be zoomed by touch-dragging\n     * with two fingers. If passed `'center'`, it will\n     * zoom to the center of the view regardless of\n     * where the touch events (fingers) were. Enabled\n     * for touch-capable web browsers.\n     * \n     * @type {(Boolean|String)}\n     */\n    touchZoom: L.Browser.touch,\n\n    /**\n     * @TODO check if this is a duplicate of `L.Map.TouchGestures::bounceAtZoomLimits`\n     * \n     * Set it to false if you don't want the map to\n     * zoom beyond min/max zoom and then bounce back\n     * when pinch-zooming.\n     * \n     * @type {Boolean}\n     */\n    bounceAtZoomLimits: false,\n\n});\n\nL.Map.TouchZoom = L.Handler.extend({\n\n    addHooks: function() {\n        // We replace the default touch zoom of Leaflet so that we need to remove handlers if already registered\n        // Cannot find a better way to retrieve the previous handler as when entering the hook the handler\n        // has already been replaced by the new one in map['touchZoom']\n        this._map._handlers.forEach(handler => {\n            if (typeof handler._onTouchMove === 'function') handler.disable();\n        });\n        L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');\n        this._map.touchGestures.enable();\n        this._map.touchGestures.zoom = true;\n    },\n\n    removeHooks: function() {\n        L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');\n        this._map.touchGestures.zoom = false;\n    },\n\n});\n\n/**\n * Add Touch Zoom handler (disabled unless `L.Browser.touch` is set).\n * \n * @property {L.Map.TouchGestures} touchGestures\n */\nL.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);\n","/**\n * A tri-state control for map rotation, states are:\n * \n * - Locked (default)\n * - Unlocked (user can pinch-rotate)\n * - Follow (rotation follows device orientation, if available)\n * \n * @typedef L.Control.Rotate\n */\n\nL.Control.Rotate = L.Control.extend({\n\n    options: {\n        position: 'topleft',\n        closeOnZeroBearing: true\n    },\n\n    onAdd: function(map) {\n        var container = this._container = L.DomUtil.create('div', 'leaflet-control-rotate leaflet-bar');\n\n        // this.button = L.Control.Zoom.prototype._createButton.call(this, 'R', 'leaflet-control-rotate', 'leaflet-control-rotate', container, this._toggleLock);\n\n        var arrow = this._arrow = L.DomUtil.create('span', 'leaflet-control-rotate-arrow');\n\n        arrow.style.backgroundImage = `url(\"data:image/svg+xml;charset=utf-8,%3Csvg width='29' height='29' viewBox='0 0 29 29' xmlns='http://www.w3.org/2000/svg' fill='%23333'%3E%3Cpath d='M10.5 14l4-8 4 8h-8z'/%3E%3Cpath d='M10.5 16l4 8 4-8h-8z' fill='%23ccc'/%3E%3C/svg%3E\")`;\n        arrow.style.cursor = 'grab';\n        arrow.style.display = 'block';\n        arrow.style.width = '100%';\n        arrow.style.height = '100%';\n        arrow.style.backgroundRepeat = 'no-repeat';\n        arrow.style.backgroundPosition = '50%';\n\n        // Copy-pasted from L.Control.Zoom\n        var link = this._link = L.DomUtil.create('a', 'leaflet-control-rotate-toggle', container);\n        link.appendChild(arrow);\n        link.href = '#';\n        link.title = 'Rotate map';\n\n        L.DomEvent\n            .on(link, 'dblclick', L.DomEvent.stopPropagation)\n            .on(link, 'mousedown', this._handleMouseDown, this)\n            .on(link, 'click', L.DomEvent.stop)\n            .on(link, 'click', this._cycleState, this)\n            .on(link, 'click', this._refocusOnMap, this);\n\n        if (!L.Browser.any3d) {\n            L.DomUtil.addClass(link, 'leaflet-disabled');\n        }\n\n        this._restyle();\n\n        map.on('rotate', this._restyle, this);\n\n        // State flag\n        this._follow = false;\n        this._canFollow = false;\n\n        if (this.options.closeOnZeroBearing && map.getBearing() === 0) {\n            container.style.display = 'none';\n        }\n\n        return container;\n    },\n    \n    onRemove: function(map) {\n        map.off('rotate', this._restyle, this);\n    },\n\n    _handleMouseDown: function(e) {\n        L.DomEvent.stop(e);\n        this.dragging = true;\n        this.dragstartX = e.pageX;\n        this.dragstartY = e.pageY;\n        L.DomEvent\n            .on(document, 'mousemove', this._handleMouseDrag, this)\n            .on(document, 'mouseup', this._handleMouseUp, this);\n    },\n\n    _handleMouseUp: function(e) {\n        L.DomEvent.stop(e);\n        this.dragging = false;\n\n        L.DomEvent\n            .off(document, 'mousemove', this._handleMouseDrag, this)\n            .off(document, 'mouseup', this._handleMouseUp, this);\n    },\n\n    _handleMouseDrag: function(e) {\n        if (!this.dragging) { return; }\n        var deltaX = e.clientX - this.dragstartX;\n        this._map.setBearing(deltaX);\n    },\n\n    _cycleState: function(ev) {\n        if (!this._map) {\n            return;\n        }\n\n        var map = this._map;\n\n        // Touch mode\n        if (!map.touchRotate.enabled() && !map.compassBearing.enabled()) {\n            map.touchRotate.enable();\n        }\n        \n        // Compass mode\n        else if (!map.compassBearing.enabled()) {\n            map.touchRotate.disable();\n            (\n                DeviceOrientationEvent && DeviceOrientationEvent.requestPermission\n                    ? DeviceOrientationEvent.requestPermission() // iOS compass\n                    : Promise.resolve('granted')                 // others\n            ).then(state => \"granted\" === state && map.compassBearing.enable())\n        }\n\n        // Locked mode\n        else {\n            map.compassBearing.disable();\n            map.setBearing(0);\n            if (this.options.closeOnZeroBearing) {\n                map.touchRotate.enable();\n            }\n        }\n        this._restyle();\n    },\n\n    _restyle: function() {\n        if (!this._map.options.rotate) {\n            L.DomUtil.addClass(this._link, 'leaflet-disabled');\n        } else {\n            var map = this._map;\n            var bearing = map.getBearing();\n\n            this._arrow.style.transform = 'rotate(' + bearing + 'deg)';\n\n            if (bearing && this.options.closeOnZeroBearing) {\n                this._container.style.display = 'block';\n            }\n\n            // Compass mode\n            if (map.compassBearing.enabled()) {\n                this._link.style.backgroundColor = 'orange';\n            }\n            \n            // Touch mode\n            else if (map.touchRotate.enabled()) {\n                this._link.style.backgroundColor = null;\n            }\n\n            // Locked mode\n            else {\n                this._link.style.backgroundColor = 'grey';\n                if (0 === bearing && this.options.closeOnZeroBearing) {\n                    this._container.style.display = 'none';\n                }\n            }\n        }\n    },\n\n});\n\nL.control.rotate = function(options) {\n    return new L.Control.Rotate(options);\n};\n\nL.Map.mergeOptions({\n    rotateControl: true,\n});\n\nL.Map.addInitHook(function() {\n    if (this.options.rotateControl) {\n        var options = typeof this.options.rotateControl === 'object' ? this.options.rotateControl : {};\n        this.rotateControl = L.control.rotate(options);\n        this.addControl(this.rotateControl);\n    }\n});\n"],"names":["domUtilProto","L","extend","DomUtil","setTransform","el","offset","scale","bearing","pivot","pos","Point","_round","apply","this","arguments","rotateFrom","style","TRANSFORM","x","y","setPosition","point","_leaflet_pos","Browser","any3d","left","top","DEG_TO_RAD","Math","PI","RAD_TO_DEG","Draggable","include","prototype","rotate","theta","sinTheta","sin","cosTheta","cos","cx","cy","divOverlayProto","DivOverlay","getEvents","_updatePosition","_map","_rotate","_zoomAnimated","anchor","_getAnchor","getPosition","_container","subtract","rotatedPointToMapPanePoint","add","popupProto","Popup","_animateZoom","e","_adjustPan","options","autoPan","_panAnim","_inProgress","_autopanning","map","marginBottom","parseInt","getStyle","containerHeight","offsetHeight","containerWidth","_containerWidth","layerPos","_containerLeft","_containerBottom","_add","containerPos","_getMapPanePos","padding","autoPanPadding","paddingTL","autoPanPaddingTopLeft","paddingBR","autoPanPaddingBottomRight","size","getSize","dx","dy","keepInView","fire","panBy","tooltipProto","Tooltip","_latLngToNewLayerPoint","_latlng","zoom","center","_setPosition","latLngToLayerPoint","Icon","_setIconStyles","img","name","sizeOption","shadowAnchor","iconAnchor","divideBy","className","marginLeft","marginTop","width","height","markerProto","Marker","markerDragProto","mergeOptions","rotation","rotateWithView","undefined","MarkerDrag","_onDrag","marker","_marker","rotated_marker","shadow","_shadow","iconPos","_icon","mapPanePointToRotatedPoint","latlng","layerPointToLatLng","oldLatLng","_oldLatLng","setLatLng","_onDragEnd","update","_initInteraction","ret","dragging","enabled","Object","getPrototypeOf","disable","assign","bind","enable","_setPos","_bearing","_zIndex","zIndexOffset","_resetZIndex","setRotation","gridLayerProto","GridLayer","events","updateWhenIdle","_onRotate","Util","throttle","_onMoveEnd","updateInterval","_getTiledPixelBounds","_getNewPixelBounds","_tileZoom","rendererProto","Renderer","_update","onAdd","version","classList","_updateTransform","getZoomScale","_zoom","_topLeft","_bounds","_getPaddedPixelBounds","min","_center","getCenter","getZoom","mapProto","Map","_animateZoomNoDelay","startAnim","_mapPane","_animatingZoom","_animateToCenter","_animateToZoom","_onZoomTransitionEnd","initialize","id","setBearing","containerPointToLayerPoint","_getRotatePanePos","layerPointToContainerPoint","_subtract","mapBoundsToContainerBounds","bounds","origin","getPixelOrigin","nw","project","getNorthWest","ne","getNorthEast","sw","getSouthWest","se","getSouthEast","max","getBounds","LatLngBounds","containerPointToLatLng","wrapNum","_getPixelCenter","oldPos","newPos","_rotatePane","_pivot","_rotatePanePos","getBearing","_initPanes","panes","_panes","_paneRenderers","createPane","_norotatePane","markerZoomAnimation","addClass","markerPane","shadowPane","panInside","abs","toFixed","paddingTopLeft","paddingBottomRight","rect","getBoundingClientRect","pixelPoint","latLngToContainerPoint","pixelBounds","pixelCenter","paddedBounds","paddedSize","contains","_enforcingBounds","centerOffset","panTo","getBoundsZoom","inside","latLngBounds","getMinZoom","getMaxZoom","boundsSize","snap","zoomSnap","scalex","scaley","getScaleZoom","round","ceil","floor","_getCenterOffset","_getNewPixelOrigin","viewHalf","_divideBy","mapZoom","halfSize","Bounds","p","padMin","multiplyBy","padMax","_handleGeolocationResponse","_leaflet_id","lat","coords","latitude","lng","longitude","hdg","heading","LatLng","toBounds","accuracy","_locateOptions","setView","maxZoom","data","timestamp","i","CompassBearing","Handler","window","__deviceOrientationEvent","_throttled","_onDeviceOrientation","addHooks","DomEvent","on","removeHooks","off","angle","webkitCompassHeading","alpha","deviceOrientation","absolute","orientation","addInitHook","trackContainerMutation","ContainerMutation","_observer","MutationObserver","invalidateSize","observe","getContainer","childList","attributes","characterData","subtree","attributeFilter","disconnect","bounceAtZoomLimits","touchRotateIntertia","TouchGestures","touchRotate","touchZoom","_onTouchStart","touches","length","_zooming","_rotating","p1","mouseEventToContainerPoint","p2","vector","_centerPoint","_startLatLng","_pinchStartLatLng","_startDist","distanceTo","_startZoom","_startTheta","atan","_startBearing","_moved","_stop","document","_onTouchMove","_onTouchEnd","preventDefault","delta","hasZoomed","bearingDelta","touchRotateInertia","_limitZoom","unproject","_moveStart","cancelAnimFrame","_animRequest","_animZoomRequest","moveFn","_move","pinch","requestAnimFrame","zoomFn","zoomAnimation","TouchRotate","touchGestures","shiftKeyRotate","ShiftKeyRotate","_handleShiftScroll","shiftKey","scrollWheelZoom","sign","deltaY","touch","TouchZoom","_handlers","forEach","handler","removeClass","Control","Rotate","position","closeOnZeroBearing","container","create","arrow","_arrow","backgroundImage","cursor","display","backgroundRepeat","backgroundPosition","link","_link","appendChild","href","title","stopPropagation","_handleMouseDown","stop","_cycleState","_refocusOnMap","_restyle","_follow","_canFollow","onRemove","dragstartX","pageX","dragstartY","pageY","_handleMouseDrag","_handleMouseUp","deltaX","clientX","ev","compassBearing","DeviceOrientationEvent","requestPermission","Promise","resolve","then","state","transform","backgroundColor","control","rotateControl","addControl"],"mappings":"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"}